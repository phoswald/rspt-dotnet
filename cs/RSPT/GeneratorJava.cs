using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace RSPT
{
    public class GeneratorRecursiveJava : Generator
    {
        public GeneratorRecursiveJava(Grammar grammar) : base(grammar) { }

        public override void Generate(TextWriter writer)
        {
            if(_grammar.Class == null) {
                _grammar.Class = "Parser";
            }
            if(_grammar.Type == null) {
                _grammar.Type = "char";
            }
            foreach(SymbolNonTerm sym in _grammar.NonTerms) {
                if(sym.Type == null) {
                    sym.Type = "Object";
                }
            }
            writer.WriteLine("//");
            writer.WriteLine("// NOTE: This file has been generated by RSPT (the Really Simple Parser Tool).");
            writer.WriteLine("//       Do not modify the contents of this file as it will be overwritten!");
            writer.WriteLine("//");
            if(_grammar.Namespace != null) {
                writer.WriteLine("package {0};", _grammar.Namespace);
                writer.WriteLine("");
            }
            foreach(string include in _grammar.Includes) {
                writer.WriteLine("import {0};", include);
            }
            writer.WriteLine("");
            writer.WriteLine("public class {0} {{", _grammar.Class);
            writer.WriteLine("");
            writer.WriteLine("    private {0}[] _input;", _grammar.Type);
            writer.WriteLine("");
            writer.WriteLine("    public {0}() {{ }}", _grammar.Class);
            writer.WriteLine("");
            foreach(string code in _grammar.Codes) {
                writer.WriteLine("    {0}", code);
            }
            foreach(SymbolNonTerm sym in _grammar.Exports) {
                writer.WriteLine("");
                writer.WriteLine("    public boolean Parse_{0}(String input, final Ref<{2}> output, final Ref_int pos) {{", sym.Name, _grammar.Type, sym.Type);
                writer.WriteLine("        _input     = input.toCharArray();");
                writer.WriteLine("        pos.val    = 0;");
                writer.WriteLine("        output.val = null;");
                writer.WriteLine("        return nt_{0}(pos, output) && pos.val == _input.length;", sym.Name);
                writer.WriteLine("    }");
            }
            bool need_ts      = false;
            bool need_tc      = false;
            bool need_tset    = false;
            bool need_trange  = false;
            bool need_tnotset = false;
            List<string> literals = new List<string> ();
            foreach(SymbolNonTerm sym in _grammar.NonTerms) {
                bool emptyclause = false;
                writer.WriteLine("");
                writer.WriteLine("    private boolean nt_{0}(final Ref_int pos, final Ref<{1}> output) {{", sym.Name, sym.Type);
                writer.WriteLine("        final Ref_int pos0 = new Ref_int(pos.val);");
                foreach(List<Symbol> rule in sym.Rules) {
                    writer.WriteLine("        {");
                    int    idx = 1;
                    string ins_to     = null;
                    bool   ins_set    = false;
                    bool   ins_range  = false;
                    bool   ins_notset = false;
                    foreach(Symbol sym2 in rule) {
                        if(sym2 is SymbolNonTerm) {
                            SymbolNonTerm sym2nt = sym2 as SymbolNonTerm;
                            if(ins_to == null) {
                                ins_to = "output"+idx;
                                writer.WriteLine("        {0}    final Ref<{1}> {2} = new Ref<{1}>(null);", _indent, sym2nt.Type, ins_to);
                            }
                            writer.WriteLine("        {0}    final Ref_int pos{1} = new Ref_int(pos{2}.val);", _indent, idx, idx-1);
                            writer.WriteLine("        {0}    if(nt_{1}(pos{2}, {3})) {{", _indent, sym2nt.Name, idx, ins_to);
                            idx++;
                            Indent(4);
                            ins_to = null;
                        } else if(sym2 is SymbolTerm) {
                            SymbolTerm sym2t = sym2 as SymbolTerm;
                            string func;
                            string text;
                            if(ins_set) { 
                                func = "tset"; need_tset = true; 
                                literals.Add(sym2t.Text);
                                text = string.Format("t_{0} /* \"{1}\" */", literals.Count, QuoteComment(sym2t.Text));
                            } else if(ins_range) { 
                                func = "trange"; need_trange = true; 
                                text = string.Format("\'{0}\', \'{1}\'", Quote(sym2t.Text.Substring(0, 1)), Quote(sym2t.Text.Substring(1, 1)));
                            } else if(ins_notset) { 
                                func = "tnotset"; need_tnotset = true; 
                                literals.Add(sym2t.Text);
                                text = string.Format("t_{0} /* \"{1}\" */", literals.Count, QuoteComment(sym2t.Text));
                            } else if(sym2t.Text.Length == 1) {
                                func = "tc"; need_tc = true;
                                text = string.Format("\'{0}\'", Quote(sym2t.Text));
                            } else {
                                func = "ts"; need_ts = true;
                                literals.Add(sym2t.Text);
                                text = string.Format("t_{0} /* \"{1}\" */", literals.Count, QuoteComment(sym2t.Text));
                            }
                            writer.WriteLine("        {0}    final Ref_int pos{1} = new Ref_int(pos{2}.val);", _indent, idx, idx-1);
                            writer.WriteLine("        {0}    if({1}(pos{2}, {3})) {{", _indent, func, idx, text);
                            idx++;
                            Indent(4);
                            ins_set    = false;
                            ins_range  = false;
                            ins_notset = false;
                        } else if(sym2 is SymbolCode) {
                            writer.WriteLine("        {0}    {1};", _indent, (sym2 as SymbolCode).Code);
                        } else if(sym2 is SymbolInstr) {
                            SymbolInstr sym2i = sym2 as SymbolInstr;
                            switch(sym2i.Instruction) {
                                case Instruction.TO:     ins_to     = sym2i.ToResult; break;
                                case Instruction.SET:    ins_set    = true;           break;
                                case Instruction.RANGE:  ins_range  = true;           break;
                                case Instruction.NOTSET: ins_notset = true;           break;
                                default: throw new Exception(string.Format("Invalid instruction {0}.", sym2i.Token));
                            }
                        }
                    }
                    if(rule.Count == 0) {
                        emptyclause = true;
                    }
                    writer.WriteLine("        {0}    pos.val = pos{1}.val;", _indent, idx-1);
                    writer.WriteLine("        {0}    return true;", _indent);
                    while(_indent.Length >= 4) {
                        writer.WriteLine("        {0}}}", _indent);
                        Indent(-4);
                    }
                    writer.WriteLine("        }");
                }
                if(!emptyclause) {
                    writer.WriteLine("        return false;");
                }
                writer.WriteLine("    }");
            }
            if(need_ts) {
                writer.WriteLine("");
                writer.WriteLine("    private boolean ts(final Ref_int pos, {0}[] s) {{", _grammar.Type);
                writer.WriteLine("        for({0} c : s) {{", _grammar.Type);
                writer.WriteLine("            if(pos.val >= _input.length || _input[pos.val] != c) return false;");
                writer.WriteLine("            pos.val++;");
                writer.WriteLine("        }");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
            }
            if(need_tc) {
                writer.WriteLine("");
                writer.WriteLine("    private boolean tc(final Ref_int pos, {0} c) {{", _grammar.Type);
                writer.WriteLine("        if(pos.val >= _input.length || _input[pos.val] != c) return false;");
                writer.WriteLine("        pos.val++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
            }
            if(need_tset) {
                writer.WriteLine("");
                writer.WriteLine("    private boolean tset(final Ref_int pos, {0}[] s) {{", _grammar.Type);
                writer.WriteLine("        for(int i = 0; i < s.length; i++) {");
                writer.WriteLine("            if(pos.val < _input.length && s[i] == _input[pos.val]) {");
                writer.WriteLine("                pos.val++;");
                writer.WriteLine("                return true;");
                writer.WriteLine("            }");
                writer.WriteLine("        }");
                writer.WriteLine("        return false;");
                writer.WriteLine("    }");
            }
            if(need_trange) {
                writer.WriteLine("");
                writer.WriteLine("    private boolean trange(final Ref_int pos, {0} c1, {0} c2) {{", _grammar.Type);
                writer.WriteLine("        if(pos.val >= _input.length || _input[pos.val] < c1 || _input[pos.val] > c2) return false;");
                writer.WriteLine("        pos.val++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
            }
            if(need_tnotset) {
                writer.WriteLine("");
                writer.WriteLine("    private boolean tnotset(final Ref_int pos, {0}[] s) {{", _grammar.Type);
                writer.WriteLine("        for(int i = 0; i < s.length; i++) {");
                writer.WriteLine("            if(pos.val >= _input.length || s[i] == _input[pos.val]) {");
                writer.WriteLine("                return false;");
                writer.WriteLine("            }");
                writer.WriteLine("        }");
                writer.WriteLine("        pos.val++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
            }
            writer.WriteLine("");
            for (int i = 0; i < literals.Count; i++) {
                writer.WriteLine("    private static final {0}[] t_{1} = \"{2}\".toCharArray();", _grammar.Type, i+1, Quote(literals[i]));
            }
            writer.WriteLine("");
            writer.WriteLine("    public final static class Ref <T> {");
            writer.WriteLine("        public T val;");
            writer.WriteLine("        public Ref(T val) { this.val = val; }");
            writer.WriteLine("    }");
            writer.WriteLine("");
            writer.WriteLine("    public final static class Ref_int {");
            writer.WriteLine("        public int val;");
            writer.WriteLine("        public Ref_int(int val) { this.val = val; }");
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }
    }
}