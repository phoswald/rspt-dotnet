using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace RSPT
{
    public class GeneratorRecursiveCPP : Generator
    {
        public GeneratorRecursiveCPP(Grammar grammar) : base(grammar) { }

        public override void Generate(TextWriter writer)
        {
            if(_grammar.Class == null) {
                _grammar.Class = "CParser";
            }
            if(_grammar.Type == null) {
                _grammar.Type = "TCHAR";
            }
            foreach(SymbolNonTerm sym in _grammar.NonTerms) {
                if(sym.Type == null) {
                    sym.Type = "void*";
                }
            }
            writer.WriteLine("//");
            writer.WriteLine("// NOTE: This file has been generated by RSPT (the Really Simple Parser Tool).");
            writer.WriteLine("//       Do not modify the contents of this file as it will be overwritten!");
            writer.WriteLine("//");
            writer.WriteLine("#pragma once;");
            foreach(string include in _grammar.Includes) {
                writer.WriteLine("#include {0}", include);
            }
            if(_grammar.Namespace != null) {
                writer.WriteLine("");
                writer.WriteLine("namespace {0} {{", _grammar.Namespace);
            }
            writer.WriteLine("");
            writer.WriteLine("class {0}", _grammar.Class);
            writer.WriteLine("{");
            writer.WriteLine("private:");
            writer.WriteLine("    const {0}* _input;", _grammar.Type);
            writer.WriteLine("    int _size;");
            writer.WriteLine("");
            writer.WriteLine("public:");
            writer.WriteLine("    {0}() : _input(NULL), _size(0) {{ }}", _grammar.Class);
            foreach(SymbolNonTerm sym in _grammar.Exports) {
                writer.WriteLine("");
                writer.WriteLine("    bool Parse_{0}(const {1}* input, int size, {2}& output, int& pos) {{", sym.Name, _grammar.Type, sym.Type);
                writer.WriteLine("        _input = input;");
                writer.WriteLine("        _size  = size;");
                writer.WriteLine("        pos    = 0;");
                writer.WriteLine("        /*output = default({0});*/", sym.Type); // TODO: fix init 
                writer.WriteLine("        return nt_{0}(pos, output) && pos == _size;", sym.Name);
                writer.WriteLine("    }");
            }
            writer.WriteLine("");
            writer.WriteLine("private:");
            bool need_ts      = false;
            bool need_tc      = false;
            bool need_tset    = false;
            bool need_trange  = false;
            bool need_tnotset = false;
            foreach(SymbolNonTerm sym in _grammar.NonTerms) {
                bool emptyclause = false;
                writer.WriteLine("    bool nt_{0}(int& pos, {1}& output) {{", sym.Name, sym.Type);
                writer.WriteLine("        int pos0 = pos;");
                foreach(List<Symbol> rule in sym.Rules) {
                    writer.WriteLine("        if(true) {");
                    int    idx = 1;
                    string ins_to     = null;
                    bool   ins_set    = false;
                    bool   ins_range  = false;
                    bool   ins_notset = false;
                    foreach(Symbol sym2 in rule) {
                        if(sym2 is SymbolNonTerm) {
                            SymbolNonTerm sym2nt = sym2 as SymbolNonTerm;
                            if(ins_to == null) {
                                ins_to = "output"+idx;
                                writer.WriteLine("        {0}    {1} {2} /*= default({1})*/;", _indent, sym2nt.Type, ins_to); // TODO: fix init 
                            }
                            writer.WriteLine("        {0}    int pos{1} = pos{2};", _indent, idx, idx-1);
                            writer.WriteLine("        {0}    if(nt_{1}(pos{2}, {3})) {{", _indent, sym2nt.Name, idx, ins_to);
                            idx++;
                            Indent(4);
                            ins_to = null;
                        } else if(sym2 is SymbolTerm) {
                            SymbolTerm sym2t = sym2 as SymbolTerm;
                            string func;
                            string text;
                            if(ins_set) { 
                                func = "tset"; need_tset = true; 
                                text = string.Format("_T(\"{0}\"), {1}", Quote(sym2t.Text), sym2t.Text.Length); // TODO: support arrays of other types
                            } else if(ins_range) { 
                                func = "trange"; need_trange = true; 
                                text = string.Format("\'{0}\', \'{1}\'", Quote(sym2t.Text.Substring(0, 1)), Quote(sym2t.Text.Substring(1, 1)));
                            } else if(ins_notset) { 
                                func = "tnotset"; need_tnotset = true; 
                                text = string.Format("_T(\"{0}\"), {1}", Quote(sym2t.Text), sym2t.Text.Length); // TODO: support arrays of other types
                            } else if(sym2t.Text.Length == 1) {
                                func = "tc"; need_tc = true;
                                text = string.Format("\'{0}\'", Quote(sym2t.Text));
                            } else {
                                func = "ts"; need_ts = true;
                                text = string.Format("_T(\"{0}\"), {1}", Quote(sym2t.Text), sym2t.Text.Length); // TODO: support arrays of other types
                            }
                            writer.WriteLine("        {0}    int pos{1} = pos{2};", _indent, idx, idx-1);
                            writer.WriteLine("        {0}    if({1}(pos{2}, {3})) {{", _indent, func, idx, text);
                            idx++;
                            Indent(4);
                            ins_set    = false;
                            ins_range  = false;
                            ins_notset = false;
                        } else if(sym2 is SymbolCode) {
                            writer.WriteLine("        {0}    {1};", _indent, (sym2 as SymbolCode).Code);
                        } else if(sym2 is SymbolInstr) {
                            SymbolInstr sym2i = sym2 as SymbolInstr;
                            switch(sym2i.Instruction) {
                                case Instruction.TO:     ins_to     = sym2i.ToResult; break;
                                case Instruction.SET:    ins_set    = true;           break;
                                case Instruction.RANGE:  ins_range  = true;           break;
                                case Instruction.NOTSET: ins_notset = true;           break;
                                default: throw new Exception(string.Format("Invalid instruction {0}.", sym2i.Token));
                            }
                        }
                    }
                    if(rule.Count == 0) {
                        emptyclause = true;
                    }
                    writer.WriteLine("        {0}    pos = pos{1};", _indent, idx-1);
                    writer.WriteLine("        {0}    return true;", _indent);
                    while(_indent.Length >= 4) {
                        writer.WriteLine("        {0}}}", _indent);
                        Indent(-4);
                    }
                    writer.WriteLine("        }");
                }
                if(!emptyclause) {
                    writer.WriteLine("        return false;");
                }
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            if(need_ts) {
                writer.WriteLine("    bool ts(int& pos, const {0}* s, int slen) {{", _grammar.Type);
                writer.WriteLine("        for(int i = 0; i < slen; i++) {");
                writer.WriteLine("            if(pos >= _size || _input[pos] != s[i]) return false;");
                writer.WriteLine("            pos++;");
                writer.WriteLine("        }");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            if(need_tc) {
                writer.WriteLine("    bool tc(int& pos, {0} c) {{", _grammar.Type);
                writer.WriteLine("        if(pos >= _size || _input[pos] != c) return false;");
                writer.WriteLine("        pos++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            if(need_tset) {
                writer.WriteLine("    bool tset(int& pos, const {0}* s, int slen) {{", _grammar.Type);
                writer.WriteLine("        for(int i = 0; i < slen; i++) {");
                writer.WriteLine("            if(pos < _size && s[i] == _input[pos]) {");
                writer.WriteLine("                pos++;");
                writer.WriteLine("                return true;");
                writer.WriteLine("            }");
                writer.WriteLine("        }");
                writer.WriteLine("        return false;");
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            if(need_trange) {
                writer.WriteLine("    bool trange(int& pos, {0} c1, {0} c2) {{", _grammar.Type);
                writer.WriteLine("        if(pos >= _size || _input[pos] < c1 || _input[pos] > c2) return false;");
                writer.WriteLine("        pos++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            if(need_tnotset) {
                writer.WriteLine("    bool tnotset(int& pos, const {0}* s, int slen) {{", _grammar.Type);
                writer.WriteLine("        for(int i = 0; i < slen; i++) {");
                writer.WriteLine("            if(pos >= _size || s[i] == _input[pos]) {");
                writer.WriteLine("                return false;");
                writer.WriteLine("            }");
                writer.WriteLine("        }");
                writer.WriteLine("        pos++;");
                writer.WriteLine("        return true;");
                writer.WriteLine("    }");
                writer.WriteLine("");
            }
            foreach(string code in _grammar.Codes) {
                writer.WriteLine("    {0}", code);
            }
            writer.WriteLine("};");
            if(_grammar.Namespace != null) {
                writer.WriteLine("}");
            }
        }
    }
}